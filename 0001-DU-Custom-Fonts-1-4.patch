From 920885063b1dde69c9b424d157a8984e237ee878 Mon Sep 17 00:00:00 2001
From: Kyle Harrison <khwebmail@gmail.com>
Date: Sat, 2 Feb 2019 20:52:03 +0000
Subject: [PATCH] DU Custom Fonts [1/4]

Change-Id: I474c04ac714ccbeac8e2b2f50a8ea98926f123d1
---
 Android.bp                                    |   1 +
 core/java/android/app/ActivityThread.java     |  11 +-
 core/java/android/content/FontInfo.aidl       |  20 +
 core/java/android/content/FontInfo.java       | 120 +++
 core/java/android/content/IFontService.aidl   |  40 +
 .../java/android/content/pm/ActivityInfo.java |   5 +
 .../android/content/res/Configuration.java    |   6 +-
 core/java/android/os/Process.java             |   6 +-
 core/java/android/os/ZygoteProcess.java       |   9 +-
 core/java/android/provider/Settings.java      |  14 +
 core/java/android/text/FontConfig.java        |  18 +-
 .../android/internal/os/ZygoteConnection.java |  10 +
 core/res/AndroidManifest.xml                  |  10 +
 core/res/res/values/du_arrays.xml             |  27 +
 core/res/res/values/du_strings.xml            |   6 +
 core/res/res/values/du_symbols.xml            |   3 +
 .../java/android/graphics/FontListParser.java |  52 +-
 graphics/java/android/graphics/Typeface.java  | 300 +++++++-
 .../SystemUI/res-keyguard/values/styles.xml   |   3 -
 .../android/keyguard/KeyguardStatusView.java  |   4 +
 .../android/systemui/BatteryMeterView.java    |   4 +
 .../phone/KeyguardBottomAreaView.java         |   4 +
 .../phone/KeyguardStatusBarView.java          |   4 +
 .../java/com/android/server/FontService.java  | 714 ++++++++++++++++++
 .../server/am/ActivityManagerService.java     |  23 +-
 .../java/com/android/server/SystemServer.java |   7 +
 26 files changed, 1358 insertions(+), 63 deletions(-)
 create mode 100644 core/java/android/content/FontInfo.aidl
 create mode 100644 core/java/android/content/FontInfo.java
 create mode 100644 core/java/android/content/IFontService.aidl
 create mode 100644 core/res/res/values/du_arrays.xml
 create mode 100644 services/core/java/com/android/server/FontService.java

diff --git a/Android.bp b/Android.bp
index 4f59cc260ae..e5bc6fc1cb2 100644
--- a/Android.bp
+++ b/Android.bp
@@ -108,6 +108,7 @@ java_library {
         ":libbluetooth-binder-aidl",
         "core/java/android/content/IClipboard.aidl",
         "core/java/android/content/IContentService.aidl",
+        "core/java/android/content/IFontService.aidl",
         "core/java/android/content/IIntentReceiver.aidl",
         "core/java/android/content/IIntentSender.aidl",
         "core/java/android/content/IOnPrimaryClipChangedListener.aidl",
diff --git a/core/java/android/app/ActivityThread.java b/core/java/android/app/ActivityThread.java
index 14a622a68fa..e09bf9e2976 100644
--- a/core/java/android/app/ActivityThread.java
+++ b/core/java/android/app/ActivityThread.java
@@ -67,6 +67,7 @@ import android.database.sqlite.SQLiteDebug;
 import android.database.sqlite.SQLiteDebug.DbStats;
 import android.graphics.Bitmap;
 import android.graphics.Canvas;
+import android.graphics.Typeface;
 import android.graphics.ImageDecoder;
 import android.hardware.display.DisplayManagerGlobal;
 import android.net.ConnectivityManager;
@@ -5240,9 +5241,13 @@ public final class ActivityThread extends ClientTransactionHandler {
         if (configDiff != 0) {
             // Ask text layout engine to free its caches if there is a locale change
             boolean hasLocaleConfigChange = ((configDiff & ActivityInfo.CONFIG_LOCALE) != 0);
-            if (hasLocaleConfigChange) {
-                Canvas.freeTextLayoutCaches();
-                if (DEBUG_CONFIGURATION) Slog.v(TAG, "Cleared TextLayout Caches");
+            boolean hasFontConfigChange = ((configDiff & ActivityInfo.CONFIG_THEME_FONT) != 0);
+            if (hasLocaleConfigChange || hasFontConfigChange) {
+                 Canvas.freeTextLayoutCaches();
+                if (hasFontConfigChange) {
+                    Typeface.recreateDefaults();
+                }
+                 if (DEBUG_CONFIGURATION) Slog.v(TAG, "Cleared TextLayout Caches");
             }
         }
     }
diff --git a/core/java/android/content/FontInfo.aidl b/core/java/android/content/FontInfo.aidl
new file mode 100644
index 00000000000..4f6b55e0edb
--- /dev/null
+++ b/core/java/android/content/FontInfo.aidl
@@ -0,0 +1,20 @@
+/**
+ * Copyright (c) 2010, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.content;
+
+parcelable FontInfo;
+
diff --git a/core/java/android/content/FontInfo.java b/core/java/android/content/FontInfo.java
new file mode 100644
index 00000000000..f7c9c526676
--- /dev/null
+++ b/core/java/android/content/FontInfo.java
@@ -0,0 +1,120 @@
+/*
+ * Copyright (C) 2018 The Dirty Unicorns Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.content;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.text.TextUtils;
+
+public class FontInfo implements Parcelable, Comparable<FontInfo> {
+    public static final String DEFAULT_FONT_PACKAGE = "android";
+    public static final String DEFAULT_FONT_NAME = "Roboto";
+    public static final String DEFAULT_FONT_PATH = "/system/fonts/Roboto-Regular.ttf";
+
+    private static final FontInfo sDefaultInfo = new FontInfo(DEFAULT_FONT_PACKAGE, DEFAULT_FONT_NAME,
+            DEFAULT_FONT_PATH);
+
+    public String packageName;
+    public String fontName;
+    public String previewPath;
+
+    public static FontInfo getDefaultFontInfo() {
+        return new FontInfo(sDefaultInfo);
+    }
+
+    public static final Parcelable.Creator<FontInfo> CREATOR = new Parcelable.Creator<FontInfo>() {
+        public FontInfo createFromParcel(Parcel in) {
+            return new FontInfo(in);
+        }
+
+        public FontInfo[] newArray(int size) {
+            return new FontInfo[size];
+        }
+    };
+
+    public FontInfo() {
+    }
+
+    public FontInfo(String packageName, String fontName, String previewPath) {
+        this.packageName = packageName;
+        this.fontName = fontName;
+        this.previewPath = previewPath;
+    }
+
+    public FontInfo(FontInfo from) {
+        this.packageName = from.packageName;
+        this.fontName = from.fontName;
+        this.previewPath = from.previewPath;
+    }
+
+    public FontInfo(Parcel in) {
+        this.packageName = in.readString();
+        this.fontName = in.readString();
+        this.previewPath = in.readString();
+    }
+
+    public void updateFrom(FontInfo info) {
+        this.packageName = info.packageName;
+        this.fontName = info.fontName;
+        this.previewPath = info.previewPath;
+    }
+
+    public String toDelimitedString() {
+        return this.packageName + "|"
+                + this.fontName + "|"
+                + this.previewPath;
+    }
+
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+
+    @Override
+    public void writeToParcel(Parcel dest, int flags) {
+        dest.writeString(this.packageName);
+        dest.writeString(this.fontName);
+        dest.writeString(this.previewPath);
+    }
+
+    @Override
+    public String toString() {
+        return "FontInfo{" +
+                "packageName='" + packageName + '\'' +
+                ", fontName='" + fontName + '\'' +
+                ", previewPath='" + previewPath + '\'' +
+                '}';
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (obj == null)
+            return false;
+        if (!(obj instanceof FontInfo))
+            return false;
+        FontInfo other = (FontInfo) obj;
+        return TextUtils.equals(this.packageName, other.packageName)
+                && TextUtils.equals(this.fontName, other.fontName)
+                && TextUtils.equals(this.previewPath, other.previewPath);
+    }
+
+    @Override
+    public int compareTo(FontInfo o) {
+        int result = this.fontName.toString().compareToIgnoreCase(o.fontName.toString());
+        return result;
+    }
+}
diff --git a/core/java/android/content/IFontService.aidl b/core/java/android/content/IFontService.aidl
new file mode 100644
index 00000000000..13803b019a6
--- /dev/null
+++ b/core/java/android/content/IFontService.aidl
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2018 The Dirty Unicorns Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.content;
+
+import android.content.FontInfo;
+
+import java.util.Map;
+
+interface IFontService {
+    /**
+     * Apply a specified font pack
+     * @param info the FontInfo object to apply
+     */
+    void applyFont(in FontInfo info);
+
+    /**
+     * @return current FontInfo
+     */
+    FontInfo getFontInfo();
+
+    /**
+     * @return A Map<String, List<FontInfo>> of all the packages that provides fonts
+     *         mapped to a list of all the fonts that package provides
+     */
+    Map getAllFonts();
+}
diff --git a/core/java/android/content/pm/ActivityInfo.java b/core/java/android/content/pm/ActivityInfo.java
index 0e91a2927c7..247ff098ab6 100644
--- a/core/java/android/content/pm/ActivityInfo.java
+++ b/core/java/android/content/pm/ActivityInfo.java
@@ -757,6 +757,11 @@ public class ActivityInfo extends ComponentInfo implements Parcelable {
      * {@link android.R.attr#configChanges} attribute.
      */
     public static final int CONFIG_LAYOUT_DIRECTION = 0x2000;
+    /**
+     * Bit in {@link #configChanges} that indicates a font change occurred
+     * @hide
+     */
+    public static final int CONFIG_THEME_FONT = 0x200000;
     /**
      * Bit in {@link #configChanges} that indicates that the activity
      * can itself handle the change to the display color gamut or dynamic
diff --git a/core/java/android/content/res/Configuration.java b/core/java/android/content/res/Configuration.java
index 193e56ef404..d5660b27daa 100644
--- a/core/java/android/content/res/Configuration.java
+++ b/core/java/android/content/res/Configuration.java
@@ -1222,6 +1222,7 @@ public final class Configuration implements Parcelable, Comparable<Configuration
         int changed = 0;
         if (delta.fontScale > 0 && fontScale != delta.fontScale) {
             changed |= ActivityInfo.CONFIG_FONT_SCALE;
+            changed |= ActivityInfo.CONFIG_THEME_FONT;
             fontScale = delta.fontScale;
         }
         if (delta.mcc != 0 && mcc != delta.mcc) {
@@ -1382,6 +1383,7 @@ public final class Configuration implements Parcelable, Comparable<Configuration
         }
         if (delta.assetsSeq != ASSETS_SEQ_UNDEFINED && delta.assetsSeq != assetsSeq) {
             changed |= ActivityInfo.CONFIG_ASSETS_PATHS;
+            changed |= ActivityInfo.CONFIG_THEME_FONT;
             assetsSeq = delta.assetsSeq;
         }
         if (delta.seq != 0) {
@@ -1450,6 +1452,7 @@ public final class Configuration implements Parcelable, Comparable<Configuration
         int changed = 0;
         if ((compareUndefined || delta.fontScale > 0) && fontScale != delta.fontScale) {
             changed |= ActivityInfo.CONFIG_FONT_SCALE;
+            changed |= ActivityInfo.CONFIG_THEME_FONT;
         }
         if ((compareUndefined || delta.mcc != 0) && mcc != delta.mcc) {
             changed |= ActivityInfo.CONFIG_MCC;
@@ -1539,6 +1542,7 @@ public final class Configuration implements Parcelable, Comparable<Configuration
         if ((compareUndefined || delta.assetsSeq != ASSETS_SEQ_UNDEFINED)
                 && assetsSeq != delta.assetsSeq) {
             changed |= ActivityInfo.CONFIG_ASSETS_PATHS;
+            changed |= ActivityInfo.CONFIG_THEME_FONT;
         }
 
         // WindowConfiguration differences aren't considered public...
@@ -1567,7 +1571,7 @@ public final class Configuration implements Parcelable, Comparable<Configuration
         // CONFIG_ASSETS_PATHS and CONFIG_FONT_SCALE are higher level configuration changes that
         // all resources are subject to change with.
         interestingChanges = interestingChanges | ActivityInfo.CONFIG_ASSETS_PATHS
-                | ActivityInfo.CONFIG_FONT_SCALE;
+                | ActivityInfo.CONFIG_FONT_SCALE | ActivityInfo.CONFIG_THEME_FONT;
         return (configChanges & interestingChanges) != 0;
     }
 
diff --git a/core/java/android/os/Process.java b/core/java/android/os/Process.java
index 1d4d4ce172b..dce481a1ef3 100644
--- a/core/java/android/os/Process.java
+++ b/core/java/android/os/Process.java
@@ -486,10 +486,11 @@ public class Process {
                                   String instructionSet,
                                   String appDataDir,
                                   String invokeWith,
+                                  boolean refreshTheme,
                                   String[] zygoteArgs) {
         return zygoteProcess.start(processClass, niceName, uid, gid, gids,
                     runtimeFlags, mountExternal, targetSdkVersion, seInfo,
-                    abi, instructionSet, appDataDir, invokeWith, zygoteArgs);
+                    abi, instructionSet, appDataDir, invokeWith, refreshTheme, zygoteArgs);
     }
 
     /** @hide */
@@ -503,10 +504,11 @@ public class Process {
                                   String instructionSet,
                                   String appDataDir,
                                   String invokeWith,
+                                  boolean refreshTheme,
                                   String[] zygoteArgs) {
         return WebViewZygote.getProcess().start(processClass, niceName, uid, gid, gids,
                     runtimeFlags, mountExternal, targetSdkVersion, seInfo,
-                    abi, instructionSet, appDataDir, invokeWith, zygoteArgs);
+                    abi, instructionSet, appDataDir, invokeWith, refreshTheme, zygoteArgs);
     }
 
     /**
diff --git a/core/java/android/os/ZygoteProcess.java b/core/java/android/os/ZygoteProcess.java
index 6994033a963..6a67ae8439a 100644
--- a/core/java/android/os/ZygoteProcess.java
+++ b/core/java/android/os/ZygoteProcess.java
@@ -227,11 +227,12 @@ public class ZygoteProcess {
                                                   String instructionSet,
                                                   String appDataDir,
                                                   String invokeWith,
+                                                  boolean refreshTheme,
                                                   String[] zygoteArgs) {
         try {
             return startViaZygote(processClass, niceName, uid, gid, gids,
                     runtimeFlags, mountExternal, targetSdkVersion, seInfo,
-                    abi, instructionSet, appDataDir, invokeWith, false /* startChildZygote */,
+                    abi, instructionSet, appDataDir, invokeWith, refreshTheme, false /* startChildZygote */,
                     zygoteArgs);
         } catch (ZygoteStartFailedEx ex) {
             Log.e(LOG_TAG,
@@ -365,6 +366,7 @@ public class ZygoteProcess {
                                                       String instructionSet,
                                                       String appDataDir,
                                                       String invokeWith,
+                                                      boolean refreshTheme,
                                                       boolean startChildZygote,
                                                       String[] extraArgs)
                                                       throws ZygoteStartFailedEx {
@@ -376,6 +378,9 @@ public class ZygoteProcess {
         argsForZygote.add("--setuid=" + uid);
         argsForZygote.add("--setgid=" + gid);
         argsForZygote.add("--runtime-flags=" + runtimeFlags);
+        if (refreshTheme) {
+            argsForZygote.add("--refresh_theme");
+        }
         if (mountExternal == Zygote.MOUNT_EXTERNAL_DEFAULT) {
             argsForZygote.add("--mount-external-default");
         } else if (mountExternal == Zygote.MOUNT_EXTERNAL_READ) {
@@ -703,7 +708,7 @@ public class ZygoteProcess {
         try {
             result = startViaZygote(processClass, niceName, uid, gid,
                     gids, runtimeFlags, 0 /* mountExternal */, 0 /* targetSdkVersion */, seInfo,
-                    abi, instructionSet, null /* appDataDir */, null /* invokeWith */,
+                    abi, instructionSet, null /* appDataDir */, null /* invokeWith */, true,
                     true /* startChildZygote */, extraArgs);
         } catch (ZygoteStartFailedEx ex) {
             throw new RuntimeException("Starting child-zygote through Zygote failed", ex);
diff --git a/core/java/android/provider/Settings.java b/core/java/android/provider/Settings.java
index cbb65e698e8..d3475bb9ee2 100644
--- a/core/java/android/provider/Settings.java
+++ b/core/java/android/provider/Settings.java
@@ -4288,6 +4288,20 @@ public final class Settings {
         private static final Validator WEATHER_LOCKSCREEN_UNIT_VALIDATOR =
                BOOLEAN_VALIDATOR;
 
+        /**
+         * Hold current font name and name of the originating package Uses "|" as a delimiter
+         *
+         * @hide
+         */
+        public static final String FONT_INFO = "font_info";
+
+        /**
+         * Hold list of installed font provider packages. Uses "|" as a delimiter
+         *
+         * @hide
+         */
+        public static final String FONT_PACKAGES = "font_packages";
+
         /**
          * Custom button brightness value for manual mode
          *
diff --git a/core/java/android/text/FontConfig.java b/core/java/android/text/FontConfig.java
index 7386e3e8856..83ae5dc2c91 100644
--- a/core/java/android/text/FontConfig.java
+++ b/core/java/android/text/FontConfig.java
@@ -25,17 +25,17 @@ import android.graphics.fonts.FontVariationAxis;
 import android.net.Uri;
 
 import java.lang.annotation.Retention;
-
+import java.util.List;
 
 /**
  * Font configuration descriptions for System fonts.
  * @hide
  */
 public final class FontConfig {
-    private final @NonNull Family[] mFamilies;
-    private final @NonNull Alias[] mAliases;
+    private final @NonNull List<Family> mFamilies;
+    private final @NonNull List<Alias> mAliases;
 
-    public FontConfig(@NonNull Family[] families, @NonNull Alias[] aliases) {
+    public FontConfig(@NonNull List<Family> families, @NonNull List<Alias> aliases) {
         mFamilies = families;
         mAliases = aliases;
     }
@@ -43,14 +43,14 @@ public final class FontConfig {
     /**
      * Returns the ordered list of families included in the system fonts.
      */
-    public @NonNull Family[] getFamilies() {
+    public @NonNull List<Family> getFamilies() {
         return mFamilies;
     }
 
     /**
      * Returns the list of aliases defined for the font families in the system fonts.
      */
-    public @NonNull Alias[] getAliases() {
+    public @NonNull List<Alias> getAliases() {
         return mAliases;
     }
 
@@ -173,7 +173,7 @@ public final class FontConfig {
      * Class that holds information about a Font family.
      */
     public static final class Family {
-        private final @NonNull String mName;
+        private String mName;
         private final @NonNull Font[] mFonts;
         private final @NonNull String[] mLanguages;
 
@@ -221,6 +221,10 @@ public final class FontConfig {
             mVariant = variant;
         }
 
+        public void clearName() {
+            mName = null;
+        }
+
         /**
          * Returns the name given by the system to this font family.
          */
diff --git a/core/java/com/android/internal/os/ZygoteConnection.java b/core/java/com/android/internal/os/ZygoteConnection.java
index f537e3e2897..7db04be0298 100644
--- a/core/java/com/android/internal/os/ZygoteConnection.java
+++ b/core/java/com/android/internal/os/ZygoteConnection.java
@@ -26,6 +26,7 @@ import static com.android.internal.os.ZygoteConnectionConstants.CONNECTION_TIMEO
 import static com.android.internal.os.ZygoteConnectionConstants.MAX_ZYGOTE_ARGC;
 import static com.android.internal.os.ZygoteConnectionConstants.WRAPPED_PID_TIMEOUT_MILLIS;
 
+import android.graphics.Typeface;
 import android.net.Credentials;
 import android.net.LocalSocket;
 import android.os.FactoryTest;
@@ -203,6 +204,10 @@ class ZygoteConnection {
             }
         }
 
+        if (parsedArgs.refreshTheme) {
+            Typeface.recreateDefaults();
+        }
+
         /**
          * In order to avoid leaking descriptors to the Zygote child,
          * the native code must close the two Zygote socket descriptors
@@ -410,6 +415,9 @@ class ZygoteConnection {
         /** from --invoke-with */
         String invokeWith;
 
+        /** from --refresh-theme */
+        boolean refreshTheme;
+
         /**
          * Any args after and including the first non-option arg
          * (or after a '--')
@@ -651,6 +659,8 @@ class ZygoteConnection {
                                 "Invalid log sampling rate: " + rateStr, nfe);
                     }
                     expectRuntimeArgs = false;
+                } else if (arg.equals("--refresh_theme")) {
+                    refreshTheme = true;
                 } else {
                     break;
                 }
diff --git a/core/res/AndroidManifest.xml b/core/res/AndroidManifest.xml
index 8cadd8c332c..34ed462060f 100644
--- a/core/res/AndroidManifest.xml
+++ b/core/res/AndroidManifest.xml
@@ -604,6 +604,9 @@
     <protected-broadcast android:name="android.intent.action.DOCK_IDLE" />
     <protected-broadcast android:name="android.intent.action.DOCK_ACTIVE" />
 
+    <!-- Font service -->
+    <protected-broadcast android:name="com.android.server.ACTION_FONT_CHANGED" />
+
     <!-- ====================================================================== -->
     <!--                          RUNTIME PERMISSIONS                           -->
     <!-- ====================================================================== -->
@@ -3552,6 +3555,13 @@
     <permission android:name="android.permission.BIND_PACKAGE_VERIFIER"
         android:protectionLevel="signature" />
 
+    <!-- Allows an application to access the font manager
+         @hide -->
+    <permission android:name="android.permission.ACCESS_FONT_MANAGER"
+        android:label="@string/permlab_accessFontManager"
+        android:description="@string/permdesc_accessFontManager"
+        android:protectionLevel="signatureOrSystem" />
+
     <!-- @SystemApi @hide Allows an application to mark other applications as harmful -->
     <permission android:name="android.permission.SET_HARMFUL_APP_WARNINGS"
         android:protectionLevel="signature|verifier" />
diff --git a/core/res/res/values/du_arrays.xml b/core/res/res/values/du_arrays.xml
new file mode 100644
index 00000000000..5b019c79691
--- /dev/null
+++ b/core/res/res/values/du_arrays.xml
@@ -0,0 +1,27 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+/* Copyright (c) 2013, The Linux Foundation. All rights reserved.
+** Not a Contribution.
+**
+** Copyright 2012, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+-->
+<resources>
+
+    <!-- System font packages (overlay in vendor) -->
+    <string-array name="config_fontPackages" translatable="false">
+    </string-array>
+
+</resources>
diff --git a/core/res/res/values/du_strings.xml b/core/res/res/values/du_strings.xml
index 416c82a4c2b..3ec57a48f2a 100644
--- a/core/res/res/values/du_strings.xml
+++ b/core/res/res/values/du_strings.xml
@@ -34,4 +34,10 @@
     <!-- Vendor mismatched fingerprint warning [CHAR LIMIT=NONE] -->
     <string name="system_error_vendorprint">Your vendor image does not match the system. Please flash the <xliff:g id="string">%s</xliff:g> vendor image for your device</string>
 
+    <!-- Font service -->
+    <!-- [CHAR LIMIT=NONE] Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_accessFontManager">access font manager</string>
+    <!-- [CHAR LIMIT=NONE] Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_accessFontManager">Allows an application to access the font manager.</string>
+
 </resources>
diff --git a/core/res/res/values/du_symbols.xml b/core/res/res/values/du_symbols.xml
index ad562732146..cea04e777be 100644
--- a/core/res/res/values/du_symbols.xml
+++ b/core/res/res/values/du_symbols.xml
@@ -162,4 +162,7 @@
   <!-- Whether device has dash charging support -->
   <java-symbol type="bool" name="config_hasDashCharger" />
 
+  <!-- System fonts -->
+  <java-symbol type="array" name="config_fontPackages" />
+
 </resources>
diff --git a/graphics/java/android/graphics/FontListParser.java b/graphics/java/android/graphics/FontListParser.java
index 431d0e0eb7b..bf16c30f4b1 100644
--- a/graphics/java/android/graphics/FontListParser.java
+++ b/graphics/java/android/graphics/FontListParser.java
@@ -23,6 +23,9 @@ import android.util.Xml;
 import org.xmlpull.v1.XmlPullParser;
 import org.xmlpull.v1.XmlPullParserException;
 
+import java.io.BufferedInputStream;
+import java.io.File;
+import java.io.FileInputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.util.ArrayList;
@@ -37,18 +40,39 @@ import java.util.regex.Pattern;
 public class FontListParser {
 
     /* Parse fallback list (no names) */
-    public static FontConfig parse(InputStream in) throws XmlPullParserException, IOException {
+    public static FontConfig parse(File configFilename, String fontDir) throws XmlPullParserException, IOException {
+        FileInputStream in = null;
+        in = new FileInputStream(configFilename);
+        return FontListParser.parse(in, fontDir);
+    }
+     /* Parse fallback list (no names) */
+    public static FontConfig parse(InputStream in, String fontDir)
+            throws XmlPullParserException, IOException {
+        BufferedInputStream bis = null;
         try {
-            XmlPullParser parser = Xml.newPullParser();
-            parser.setInput(in, null);
-            parser.nextTag();
-            return readFamilies(parser);
+            // wrap input stream in a BufferedInputStream, if it's not already, for mark support
+            if (!(in instanceof BufferedInputStream)) {
+                bis = new BufferedInputStream(in);
+            } else {
+                bis = (BufferedInputStream) in;
+            }
+            // mark the beginning so we can reset to this position after checking format
+            bis.mark(in.available());
+            return parseNormalFormat(bis, fontDir);
         } finally {
-            in.close();
+            if (bis != null) bis.close();
         }
     }
 
-    private static FontConfig readFamilies(XmlPullParser parser)
+    public static FontConfig parseNormalFormat(InputStream in, String dirName)
+            throws XmlPullParserException, IOException {
+        XmlPullParser parser = Xml.newPullParser();
+        parser.setInput(in, null);
+        parser.nextTag();
+        return readFamilies(parser, dirName);
+    }
+
+    private static FontConfig readFamilies(XmlPullParser parser, String dirPath)
             throws XmlPullParserException, IOException {
         List<FontConfig.Family> families = new ArrayList<>();
         List<FontConfig.Alias> aliases = new ArrayList<>();
@@ -58,18 +82,17 @@ public class FontListParser {
             if (parser.getEventType() != XmlPullParser.START_TAG) continue;
             String tag = parser.getName();
             if (tag.equals("family")) {
-                families.add(readFamily(parser));
+                families.add(readFamily(parser,dirPath));
             } else if (tag.equals("alias")) {
                 aliases.add(readAlias(parser));
             } else {
                 skip(parser);
             }
         }
-        return new FontConfig(families.toArray(new FontConfig.Family[families.size()]),
-                aliases.toArray(new FontConfig.Alias[aliases.size()]));
+        return new FontConfig(families,aliases);
     }
 
-    private static FontConfig.Family readFamily(XmlPullParser parser)
+    private static FontConfig.Family readFamily(XmlPullParser parser,String dirPath)
             throws XmlPullParserException, IOException {
         final String name = parser.getAttributeValue(null, "name");
         final String lang = parser.getAttributeValue(null, "lang");
@@ -80,7 +103,7 @@ public class FontListParser {
             if (parser.getEventType() != XmlPullParser.START_TAG) continue;
             final String tag = parser.getName();
             if (tag.equals("font")) {
-                fonts.add(readFont(parser));
+                fonts.add(readFont(parser,dirPath));
             } else {
                 skip(parser);
             }
@@ -101,7 +124,7 @@ public class FontListParser {
     private static final Pattern FILENAME_WHITESPACE_PATTERN =
             Pattern.compile("^[ \\n\\r\\t]+|[ \\n\\r\\t]+$");
 
-    private static FontConfig.Font readFont(XmlPullParser parser)
+    private static FontConfig.Font readFont(XmlPullParser parser, String dirPath)
             throws XmlPullParserException, IOException {
         String indexStr = parser.getAttributeValue(null, "index");
         int index = indexStr == null ? 0 : Integer.parseInt(indexStr);
@@ -123,7 +146,8 @@ public class FontListParser {
                 skip(parser);
             }
         }
-        String sanitizedName = FILENAME_WHITESPACE_PATTERN.matcher(filename).replaceAll("");
+        String sanitizedName = dirPath + File.separatorChar +
+                FILENAME_WHITESPACE_PATTERN.matcher(filename).replaceAll("");
         return new FontConfig.Font(sanitizedName, index,
                 axes.toArray(new FontVariationAxis[axes.size()]), weight, isItalic, fallbackFor);
     }
diff --git a/graphics/java/android/graphics/Typeface.java b/graphics/java/android/graphics/Typeface.java
index 18dd97f8ace..8164111473b 100644
--- a/graphics/java/android/graphics/Typeface.java
+++ b/graphics/java/android/graphics/Typeface.java
@@ -31,6 +31,7 @@ import android.net.Uri;
 import android.provider.FontRequest;
 import android.provider.FontsContract;
 import android.text.FontConfig;
+import android.text.FontConfig.Family;
 import android.util.ArrayMap;
 import android.util.Base64;
 import android.util.Log;
@@ -79,19 +80,19 @@ public class Typeface {
             Typeface.class.getClassLoader(), nativeGetReleaseFunc(), 64);
 
     /** The default NORMAL typeface object */
-    public static final Typeface DEFAULT;
+    public static Typeface DEFAULT;
     /**
      * The default BOLD typeface object. Note: this may be not actually be
      * bold, depending on what fonts are installed. Call getStyle() to know
      * for sure.
      */
-    public static final Typeface DEFAULT_BOLD;
+    public static Typeface DEFAULT_BOLD;
     /** The NORMAL style of the default sans serif typeface. */
-    public static final Typeface SANS_SERIF;
+    public static Typeface SANS_SERIF;
     /** The NORMAL style of the default serif typeface. */
-    public static final Typeface SERIF;
+    public static Typeface SERIF;
     /** The NORMAL style of the default monospace typeface. */
-    public static final Typeface MONOSPACE;
+    public static Typeface MONOSPACE;
 
     static Typeface[] sDefaults;
 
@@ -99,9 +100,9 @@ public class Typeface {
      * Cache for Typeface objects for style variant. Currently max size is 3.
      */
     @GuardedBy("sStyledCacheLock")
-    private static final LongSparseArray<SparseArray<Typeface>> sStyledTypefaceCache =
+    private static LongSparseArray<SparseArray<Typeface>> sStyledTypefaceCache =
             new LongSparseArray<>(3);
-    private static final Object sStyledCacheLock = new Object();
+    private static Object sStyledCacheLock = new Object();
 
     /**
      * Cache for Typeface objects for weight variant. Currently max size is 3.
@@ -119,9 +120,14 @@ public class Typeface {
     private static final Object sDynamicCacheLock = new Object();
 
     static Typeface sDefaultTypeface;
-    static final Map<String, Typeface> sSystemFontMap;
+    static Map<String, Typeface> sSystemFontMap;
+    static FontFamily[] sFallbackFonts;
     static final Map<String, FontFamily[]> sSystemFallbackMap;
 
+    static final String FONTS_CONFIG = "fonts.xml";
+
+    static final String SANS_SERIF_FAMILY_NAME = "sans-serif";
+
     /**
      * @hide
      */
@@ -152,8 +158,8 @@ public class Typeface {
     // Value for weight and italic. Indicates the value is resolved by font metadata.
     // Must be the same as the C++ constant in core/jni/android/graphics/FontFamily.cpp
     /** @hide */
-    public static final int RESOLVE_BY_FONT_TABLE = -1;
-    private static final String DEFAULT_FAMILY = "sans-serif";
+    public static int RESOLVE_BY_FONT_TABLE = -1;
+    private static String DEFAULT_FAMILY = "sans-serif";
 
     // Style value for building typeface.
     private static final int STYLE_NORMAL = 0;
@@ -162,6 +168,12 @@ public class Typeface {
     private int[] mSupportedAxes;
     private static final int[] EMPTY_AXES = {};
 
+    private static Typeface DEFAULT_INTERNAL;
+    private static Typeface DEFAULT_BOLD_INTERNAL;
+    private static Typeface SANS_SERIF_INTERNAL;
+    private static Typeface SERIF_INTERNAL;
+    private static Typeface MONOSPACE_INTERNAL;
+
     private static void setDefault(Typeface t) {
         sDefaultTypeface = t;
         nativeSetDefault(t.native_instance);
@@ -896,17 +908,26 @@ public class Typeface {
         for (int i = 0; i < families.length; i++) {
             ptrArray[i] = families[i].mNativePtr;
         }
-        return new Typeface(nativeCreateFromArray(
+        Typeface typeface = new Typeface(nativeCreateFromArray(
                 ptrArray, RESOLVE_BY_FONT_TABLE, RESOLVE_BY_FONT_TABLE));
+        return typeface;
     }
 
     /**
      * This method is used by supportlib-v27.
      * TODO: Remove private API use in supportlib: http://b/72665240
      */
-    private static Typeface createFromFamiliesWithDefault(FontFamily[] families, int weight,
-                int italic) {
-        return createFromFamiliesWithDefault(families, DEFAULT_FAMILY, weight, italic);
+    private static Typeface createFromFamiliesWithDefault(FontFamily[] families,
+                int weight, int italic) {
+        long[] ptrArray = new long[families.length + sFallbackFonts.length];
+        for (int i = 0; i < families.length; i++) {
+            ptrArray[i] = families[i].mNativePtr;
+        }
+        for (int i = 0; i < sFallbackFonts.length; i++) {
+            ptrArray[i + families.length] = sFallbackFonts[i].mNativePtr;
+        }
+        Typeface typeface = new Typeface(nativeCreateFromArray(ptrArray, weight, italic));
+        return typeface;
     }
 
     /**
@@ -950,6 +971,37 @@ public class Typeface {
         mWeight = nativeGetWeight(ni);
     }
 
+    private static FontFamily makeFamilyFromParsed(FontConfig.Family family,
+            Map<String, ByteBuffer> bufferForPath) {
+        FontFamily fontFamily = new FontFamily(family.getLanguages(), family.getVariant());
+        for (FontConfig.Font font : family.getFonts()) {
+            String fullPathName = font.getFontName();
+            ByteBuffer fontBuffer = bufferForPath.get(fullPathName);
+            if (fontBuffer == null) {
+                try (FileInputStream file = new FileInputStream(fullPathName)) {
+                    FileChannel fileChannel = file.getChannel();
+                    long fontSize = fileChannel.size();
+                    fontBuffer = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0, fontSize);
+                    bufferForPath.put(fullPathName, fontBuffer);
+                } catch (IOException e) {
+                    Log.e(TAG, "Error mapping font file " + fullPathName);
+                    continue;
+                }
+            }
+            if (!fontFamily.addFontFromBuffer(fontBuffer, font.getTtcIndex(), font.getAxes(),
+                    font.getWeight(), font.isItalic() ? STYLE_ITALIC : STYLE_NORMAL)) {
+                Log.e(TAG, "Error creating font " + fullPathName + "#" + font.getTtcIndex());
+            }
+        }
+        if (!fontFamily.freeze()) {
+            // Treat as system error since reaching here means that a system pre-installed font
+            // can't be used by our font stack.
+            Log.e(TAG, "Unable to load Family: " + family.getName() + ":" + family.getLanguages());
+            return null;
+        }
+        return fontFamily;
+    }
+
     private static @Nullable ByteBuffer mmap(String fullPath) {
         try (FileInputStream file = new FileInputStream(fullPath)) {
             final FileChannel fileChannel = file.getChannel();
@@ -967,7 +1019,7 @@ public class Typeface {
         final FontFamily family = new FontFamily(languageTags, variant);
         for (int i = 0; i < fonts.size(); i++) {
             final FontConfig.Font font = fonts.get(i);
-            final String fullPath = fontDir + font.getFontName();
+            final String fullPath = font.getFontName();
             ByteBuffer buffer = cache.get(fullPath);
             if (buffer == null) {
                 if (cache.containsKey(fullPath)) {
@@ -1057,11 +1109,11 @@ public class Typeface {
     public static void buildSystemFallback(String xmlPath, String fontDir,
             ArrayMap<String, Typeface> fontMap, ArrayMap<String, FontFamily[]> fallbackMap) {
         try {
-            final FileInputStream fontsIn = new FileInputStream(xmlPath);
-            final FontConfig fontConfig = FontListParser.parse(fontsIn);
+            final InputStream xmlFile = new FileInputStream(xmlPath);
+            final FontConfig fontConfig = FontListParser.parse(xmlFile, fontDir);
 
             final HashMap<String, ByteBuffer> bufferCache = new HashMap<String, ByteBuffer>();
-            final FontConfig.Family[] xmlFamilies = fontConfig.getFamilies();
+            final List<FontConfig.Family> xmlFamilies = fontConfig.getFamilies();
 
             final ArrayMap<String, ArrayList<FontFamily>> fallbackListMap = new ArrayMap<>();
             // First traverse families which have a 'name' attribute to create fallback map.
@@ -1082,8 +1134,8 @@ public class Typeface {
             }
 
             // Then, add fallback fonts to the each fallback map.
-            for (int i = 0; i < xmlFamilies.length; i++) {
-                final FontConfig.Family xmlFamily = xmlFamilies[i];
+            for (int i = 0; i < xmlFamilies.size(); i++) {
+                final FontConfig.Family xmlFamily = xmlFamilies.get(i);
                 // The first family (usually the sans-serif family) is always placed immediately
                 // after the primary family in the fallback.
                 if (i == 0 || xmlFamily.getName() == null) {
@@ -1128,16 +1180,200 @@ public class Typeface {
         }
     }
 
+    private static void addFallbackFontsForFamilyName(FontConfig src,
+            FontConfig dst, String familyName) {
+        for (Family srcFamily : src.getFamilies()) {
+            if (familyName.equals(srcFamily.getName())) {
+                // set the name to null so that it will be added as a fallback
+                srcFamily.clearName();
+                dst.getFamilies().add(srcFamily);
+                return;
+            }
+        }
+    }
+
+    /**
+     * Adds any font families in src that do not exist in dst
+     * @param src Source font config
+     * @param dst Destination font config
+     */
+    private static void addMissingFontFamilies(FontConfig src,
+            FontConfig dst) {
+        final int N = dst.getFamilies().size();
+        // add missing families
+        for (Family srcFamily : src.getFamilies()) {
+            boolean addFamily = true;
+            for (int i = 0; i < N && addFamily; i++) {
+                final Family dstFamily = dst.getFamilies().get(i);
+                final String dstFamilyName = dstFamily.getName();
+                if (dstFamilyName != null && dstFamilyName.equals(srcFamily.getName())) {
+                    addFamily = false;
+                    break;
+                }
+            }
+            if (addFamily) {
+                dst.getFamilies().add(srcFamily);
+            }
+        }
+    }
+
+    /**
+     * Adds any aliases in src that do not exist in dst
+     * @param src Source font config
+     * @param dst Destination font config
+     */
+    private static void addMissingFontAliases(FontConfig src,
+            FontConfig dst) {
+        final int N = dst.getAliases().size();
+        // add missing aliases
+        for (FontConfig.Alias alias : src.getAliases()) {
+            boolean addAlias = true;
+            for (int i = 0; i < N && addAlias; i++) {
+                final String dstAliasName = dst.getAliases().get(i).getName();
+                if (dstAliasName != null && dstAliasName.equals(alias.getName())) {
+                    addAlias = false;
+                    break;
+                }
+            }
+            if (addAlias) {
+                dst.getAliases().add(alias);
+            }
+        }
+    }
+
+
+    private static void init() {
+        // Load font config and initialize Minikin state
+        File systemFontConfigLocation = getSystemFontConfigLocation();
+        File themeFontConfigLocation = getThemeFontConfigLocation();
+
+        File systemConfigFile = new File(systemFontConfigLocation, FONTS_CONFIG);
+        File themeConfigFile = new File(themeFontConfigLocation, FONTS_CONFIG);
+        File configFile = null;
+        File fontDir;
+
+        if (themeConfigFile.exists()) {
+            // /data/system/theme/fonts/ exists so use it and copy default fonts
+            configFile = themeConfigFile;
+            fontDir = getThemeFontDirLocation();
+        } else {
+            configFile = systemConfigFile;
+            fontDir = getSystemFontDirLocation();
+        }
+
+        try {
+            FontConfig fontConfig = FontListParser.parse(configFile,
+                    fontDir.getAbsolutePath());
+            FontConfig systemFontConfig = null;
+
+            // If the fonts are coming from a theme, we will need to make sure that we include
+            // any font families from the system fonts that the theme did not include.
+            // NOTE: All the system font families without names ALWAYS get added.
+            if (configFile == themeConfigFile) {
+                systemFontConfig = FontListParser.parse(systemConfigFile,
+                        getSystemFontDirLocation().getAbsolutePath());
+                addFallbackFontsForFamilyName(systemFontConfig, fontConfig, SANS_SERIF_FAMILY_NAME);
+                addMissingFontFamilies(systemFontConfig, fontConfig);
+                addMissingFontAliases(systemFontConfig, fontConfig);
+            }
+
+            Map<String, ByteBuffer> bufferForPath = new HashMap<String, ByteBuffer>();
+
+            List<FontFamily> familyList = new ArrayList<FontFamily>();
+            // Note that the default typeface is always present in the fallback list;
+            // this is an enhancement from pre-Minikin behavior.
+            for (int i = 0; i < fontConfig.getFamilies().size(); i++) {
+                FontConfig.Family f = fontConfig.getFamilies().get(i);
+                if (i == 0 || f.getName() == null) {
+                    FontFamily family = makeFamilyFromParsed(f, bufferForPath);
+                    if (family != null) {
+                        familyList.add(family);
+                    }
+                }
+            }
+            sFallbackFonts = familyList.toArray(new FontFamily[familyList.size()]);
+            setDefault(Typeface.createFromFamilies(sFallbackFonts));
+
+            Map<String, Typeface> systemFonts = new HashMap<String, Typeface>();
+            for (int i = 0; i < fontConfig.getFamilies().size(); i++) {
+                Typeface typeface;
+                FontConfig.Family f = fontConfig.getFamilies().get(i);
+                if (f.getName() != null) {
+                    if (i == 0) {
+                        // The first entry is the default typeface; no sense in
+                        // duplicating the corresponding FontFamily.
+                        typeface = sDefaultTypeface;
+                    } else {
+                        FontFamily fontFamily = makeFamilyFromParsed(f, bufferForPath);
+                        if (fontFamily == null) {
+                            continue;
+                        }
+                        FontFamily[] families = { fontFamily };
+                        typeface = Typeface.createFromFamiliesWithDefault(families,
+                                RESOLVE_BY_FONT_TABLE, RESOLVE_BY_FONT_TABLE);
+                    }
+                    systemFonts.put(f.getName(), typeface);
+                }
+            }
+            for (FontConfig.Alias alias : fontConfig.getAliases()) {
+                Typeface base = systemFonts.get(alias.getToName());
+                Typeface newFace = base;
+                int weight = alias.getWeight();
+                if (weight != 400) {
+                    newFace = new Typeface(nativeCreateWeightAlias(base.native_instance, weight));
+                }
+                systemFonts.put(alias.getName(), newFace);
+            }
+            sSystemFontMap = systemFonts;
+
+        } catch (RuntimeException e) {
+            Log.w(TAG, "Didn't create default family (most likely, non-Minikin build)", e);
+            // TODO: normal in non-Minikin case, remove or make error when Minikin-only
+        } catch (FileNotFoundException e) {
+            Log.e(TAG, "Error opening " + configFile, e);
+        } catch (IOException e) {
+            Log.e(TAG, "Error reading " + configFile, e);
+        } catch (XmlPullParserException e) {
+            Log.e(TAG, "XML parse exception for " + configFile, e);
+        }
+    }
+
+    public static void recreateDefaults() {
+        sDynamicTypefaceCache.evictAll();
+        sSystemFontMap.clear();
+        sStyledTypefaceCache.clear();
+        init();
+        DEFAULT_BOLD_INTERNAL = create((String) null, Typeface.BOLD);
+        SANS_SERIF_INTERNAL = create("sans-serif", 0);
+        SERIF_INTERNAL = create("serif", 0);
+        MONOSPACE_INTERNAL = create("monospace", 0);
+
+        DEFAULT.native_instance = DEFAULT_INTERNAL.native_instance;
+        DEFAULT_BOLD.native_instance = DEFAULT_BOLD_INTERNAL.native_instance;
+        SANS_SERIF.native_instance = SANS_SERIF_INTERNAL.native_instance;
+        SERIF.native_instance = SERIF_INTERNAL.native_instance;
+        MONOSPACE.native_instance = MONOSPACE_INTERNAL.native_instance;
+        sDefaults[2] = create((String) null, Typeface.ITALIC);
+        sDefaults[3] = create((String) null, Typeface.BOLD_ITALIC);
+    }
+
     static {
-        final ArrayMap<String, Typeface> systemFontMap = new ArrayMap<>();
-        final ArrayMap<String, FontFamily[]> systemFallbackMap = new ArrayMap<>();
+        init();
+        ArrayMap<String, Typeface> systemFontMap = new ArrayMap<>();
+        ArrayMap<String, FontFamily[]> systemFallbackMap = new ArrayMap<>();
         buildSystemFallback("/system/etc/fonts.xml", "/system/fonts/", systemFontMap,
                 systemFallbackMap);
-        sSystemFontMap = Collections.unmodifiableMap(systemFontMap);
-        sSystemFallbackMap = Collections.unmodifiableMap(systemFallbackMap);
+        sSystemFontMap = systemFontMap;
+        sSystemFallbackMap = systemFallbackMap;
 
         setDefault(sSystemFontMap.get(DEFAULT_FAMILY));
 
+        DEFAULT_INTERNAL         = create((String) null, 0);
+        DEFAULT_BOLD_INTERNAL    = create((String) null, Typeface.BOLD);
+        SANS_SERIF_INTERNAL      = create("sans-serif", 0);
+        SERIF_INTERNAL           = create("serif", 0);
+        MONOSPACE_INTERNAL       = create("monospace", 0);
+
         // Set up defaults and typefaces exposed in public API
         DEFAULT         = create((String) null, 0);
         DEFAULT_BOLD    = create((String) null, Typeface.BOLD);
@@ -1154,6 +1390,22 @@ public class Typeface {
 
     }
 
+    private static File getSystemFontConfigLocation() {
+        return new File("/system/etc/");
+    }
+
+    private static File getSystemFontDirLocation() {
+        return new File("/system/fonts/");
+    }
+
+    private static File getThemeFontConfigLocation() {
+        return new File("/data/system/theme/fonts/");
+    }
+
+    private static File getThemeFontDirLocation() {
+        return new File("/data/system/theme/fonts/");
+    }
+
     @Override
     public boolean equals(Object o) {
         if (this == o) return true;
diff --git a/packages/SystemUI/res-keyguard/values/styles.xml b/packages/SystemUI/res-keyguard/values/styles.xml
index b90b4dd3a58..3dd9e9ef0b8 100644
--- a/packages/SystemUI/res-keyguard/values/styles.xml
+++ b/packages/SystemUI/res-keyguard/values/styles.xml
@@ -33,7 +33,6 @@
         <item name="android:gravity">center_horizontal|center_vertical</item>
         <item name="android:background">@null</item>
         <item name="android:textSize">32sp</item>
-        <item name="android:fontFamily">@*android:string/config_headlineFontFamilyLight</item>
         <item name="android:textColor">?attr/wallpaperTextColor</item>
         <item name="android:paddingBottom">-16dp</item>
     </style>
@@ -42,7 +41,6 @@
     </style>
     <style name="Widget.TextView.NumPadKey.Klondike" parent="Widget.TextView.NumPadKey">
         <item name="android:textSize">12sp</item>
-        <item name="android:fontFamily">sans-serif</item>
         <item name="android:textColor">?attr/wallpaperTextColorSecondary</item>
         <item name="android:paddingBottom">0dp</item>
     </style>
@@ -84,7 +82,6 @@
         <item name="android:gravity">center</item>
         <item name="android:ellipsize">end</item>
         <item name="android:maxLines">2</item>
-        <item name="android:fontFamily">@*android:string/config_headlineFontFamilyLight</item>
     </style>
 
     <style name="TextAppearance.Keyguard.Secondary">
diff --git a/packages/SystemUI/src/com/android/keyguard/KeyguardStatusView.java b/packages/SystemUI/src/com/android/keyguard/KeyguardStatusView.java
index a24b39e77ce..d867627f6e4 100644
--- a/packages/SystemUI/src/com/android/keyguard/KeyguardStatusView.java
+++ b/packages/SystemUI/src/com/android/keyguard/KeyguardStatusView.java
@@ -25,6 +25,7 @@ import android.content.ContentResolver;
 import android.content.res.Resources;
 import android.graphics.Color;
 import android.graphics.Paint;
+import android.graphics.Typeface;
 import android.os.Handler;
 import android.os.Looper;
 import android.os.RemoteException;
@@ -64,6 +65,7 @@ public class KeyguardStatusView extends GridLayout implements
     private static final boolean DEBUG = KeyguardConstants.DEBUG;
     private static final String TAG = "KeyguardStatusView";
     private static final int MARQUEE_DELAY_MS = 2000;
+    private static final String FONT_FAMILY = "sans-serif-light";
 
     private final LockPatternUtils mLockPatternUtils;
     private final IActivityManager mIActivityManager;
@@ -231,12 +233,14 @@ public class KeyguardStatusView extends GridLayout implements
         boolean smallClock = mKeyguardSlice.hasHeader() || mPulsing;
         prepareSmallView(smallClock);
         float clockScale = smallClock ? mSmallClockScale : 1;
+	Typeface tf = Typeface.create(FONT_FAMILY, Typeface.NORMAL);
 
         RelativeLayout.LayoutParams layoutParams =
                 (RelativeLayout.LayoutParams) mClockView.getLayoutParams();
         int height = mClockView.getHeight();
         layoutParams.bottomMargin = (int) -(height - (clockScale * height));
         mClockView.setLayoutParams(layoutParams);
+        mClockView.setTypeface(tf);
 
         // Custom analog clock
         RelativeLayout.LayoutParams customlayoutParams =
diff --git a/packages/SystemUI/src/com/android/systemui/BatteryMeterView.java b/packages/SystemUI/src/com/android/systemui/BatteryMeterView.java
index c213b45b9fd..5101186af84 100644
--- a/packages/SystemUI/src/com/android/systemui/BatteryMeterView.java
+++ b/packages/SystemUI/src/com/android/systemui/BatteryMeterView.java
@@ -27,6 +27,7 @@ import android.content.res.Resources;
 import android.content.res.TypedArray;
 import android.database.ContentObserver;
 import android.graphics.Rect;
+import android.graphics.Typeface;
 import android.net.Uri;
 import android.os.Handler;
 import android.provider.Settings;
@@ -66,6 +67,7 @@ public class BatteryMeterView extends LinearLayout implements
     private ImageView mBatteryIconView;
     private final CurrentUserTracker mUserTracker;
     private TextView mBatteryPercentView;
+    private static final String FONT_FAMILY = "sans-serif-medium";
 
     private BatteryController mBatteryController;
     private SettingObserver mSettingObserver;
@@ -274,6 +276,7 @@ public class BatteryMeterView extends LinearLayout implements
     }
 
     private void updatePercentText() {
+        Typeface tf = Typeface.create(FONT_FAMILY, Typeface.NORMAL);
         if (mBatteryPercentView != null) {
             // Use the high voltage symbol ⚡ (u26A1 unicode) but prevent the system
             // to load its emoji colored variant with the uFE0E flag
@@ -283,6 +286,7 @@ public class BatteryMeterView extends LinearLayout implements
                     ? (bolt + " ") : "";
             mBatteryPercentView.setText(mChargeIndicator +
                     NumberFormat.getPercentInstance().format(mLevel / 100f));
+            mBatteryPercentView.setTypeface(tf);
         }
     }
 
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/phone/KeyguardBottomAreaView.java b/packages/SystemUI/src/com/android/systemui/statusbar/phone/KeyguardBottomAreaView.java
index 60d62d52995..d51400f23d5 100644
--- a/packages/SystemUI/src/com/android/systemui/statusbar/phone/KeyguardBottomAreaView.java
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/phone/KeyguardBottomAreaView.java
@@ -38,6 +38,7 @@ import android.content.pm.PackageManager;
 import android.content.pm.ResolveInfo;
 import android.content.res.Configuration;
 import android.graphics.drawable.Drawable;
+import android.graphics.Typeface;
 import android.os.AsyncTask;
 import android.os.Bundle;
 import android.os.IBinder;
@@ -95,6 +96,7 @@ public class KeyguardBottomAreaView extends FrameLayout implements View.OnClickL
         AccessibilityController.AccessibilityStateChangedCallback, View.OnLongClickListener {
 
     final static String TAG = "StatusBar/KeyguardBottomAreaView";
+    private static final String FONT_FAMILY = "sans-serif";
 
     public static final String CAMERA_LAUNCH_SOURCE_AFFORDANCE = "lockscreen_affordance";
     public static final String CAMERA_LAUNCH_SOURCE_WIGGLE = "wiggle_gesture";
@@ -316,6 +318,7 @@ public class KeyguardBottomAreaView extends FrameLayout implements View.OnClickL
     @Override
     protected void onConfigurationChanged(Configuration newConfig) {
         super.onConfigurationChanged(newConfig);
+    	Typeface tf = Typeface.create(FONT_FAMILY, Typeface.ITALIC);
         mIndicationBottomMargin = getResources().getDimensionPixelSize(
                 R.dimen.keyguard_indication_margin_bottom);
         mIndicationBottomMarginAmbient = getResources().getDimensionPixelSize(
@@ -335,6 +338,7 @@ public class KeyguardBottomAreaView extends FrameLayout implements View.OnClickL
         mIndicationText.setTextSize(TypedValue.COMPLEX_UNIT_PX,
                 getResources().getDimensionPixelSize(
                         com.android.internal.R.dimen.text_size_small_material));
+        mIndicationText.setTypeface(tf);
 
         ViewGroup.LayoutParams lp = mRightAffordanceView.getLayoutParams();
         lp.width = getResources().getDimensionPixelSize(R.dimen.keyguard_affordance_width);
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/phone/KeyguardStatusBarView.java b/packages/SystemUI/src/com/android/systemui/statusbar/phone/KeyguardStatusBarView.java
index 7f9526e47fc..4a1546d442d 100644
--- a/packages/SystemUI/src/com/android/systemui/statusbar/phone/KeyguardStatusBarView.java
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/phone/KeyguardStatusBarView.java
@@ -26,6 +26,7 @@ import android.graphics.Color;
 import android.graphics.Rect;
 import android.database.ContentObserver;
 import android.graphics.drawable.Drawable;
+import android.graphics.Typeface;
 import android.net.Uri;
 import android.os.Handler;
 import android.os.UserHandle;
@@ -68,6 +69,7 @@ import com.android.systemui.statusbar.policy.UserSwitcherController;
 public class KeyguardStatusBarView extends RelativeLayout
         implements BatteryStateChangeCallback, OnUserInfoChangedListener, ConfigurationListener {
 
+    private static final String FONT_FAMILY = "sans-serif";
     private static final int LAYOUT_NONE = 0;
     private static final int LAYOUT_CUTOUT = 1;
     private static final int LAYOUT_NO_CUTOUT = 2;
@@ -142,6 +144,7 @@ public class KeyguardStatusBarView extends RelativeLayout
     protected void onConfigurationChanged(Configuration newConfig) {
         super.onConfigurationChanged(newConfig);
 
+        Typeface tf = Typeface.create(FONT_FAMILY, Typeface.NORMAL);
         MarginLayoutParams lp = (MarginLayoutParams) mMultiUserAvatar.getLayoutParams();
         lp.width = lp.height = getResources().getDimensionPixelSize(
                 R.dimen.multi_user_avatar_keyguard_size);
@@ -169,6 +172,7 @@ public class KeyguardStatusBarView extends RelativeLayout
         mCarrierLabel.setTextSize(TypedValue.COMPLEX_UNIT_PX,
                 getResources().getDimensionPixelSize(
                         com.android.internal.R.dimen.text_size_small_material));
+        mCarrierLabel.setTypeface(tf);
         lp = (MarginLayoutParams) mCarrierLabel.getLayoutParams();
         lp.setMarginStart(
                 getResources().getDimensionPixelSize(R.dimen.keyguard_carrier_text_margin));
diff --git a/services/core/java/com/android/server/FontService.java b/services/core/java/com/android/server/FontService.java
new file mode 100644
index 00000000000..e1219669558
--- /dev/null
+++ b/services/core/java/com/android/server/FontService.java
@@ -0,0 +1,714 @@
+/*
+ * Copyright (C) 2018 The Dirty Unicorns Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server;
+
+import static android.content.Intent.ACTION_PACKAGE_ADDED;
+import static android.content.Intent.ACTION_PACKAGE_CHANGED;
+import static android.content.Intent.ACTION_PACKAGE_REMOVED;
+
+import java.io.BufferedInputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipInputStream;
+
+import org.xmlpull.v1.XmlPullParser;
+import org.xmlpull.v1.XmlPullParserException;
+import org.xmlpull.v1.XmlPullParserFactory;
+
+import android.annotation.NonNull;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.IFontService;
+import android.content.FontInfo;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.pm.ApplicationInfo;
+import android.content.pm.PackageManager;
+import android.content.pm.ResolveInfo;
+import android.content.pm.PackageManager.NameNotFoundException;
+import android.content.res.AssetManager;
+import android.graphics.FontListParser;
+import android.graphics.Typeface;
+import android.net.Uri;
+import android.os.Binder;
+import android.os.Environment;
+import android.os.FileUtils;
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.os.Looper;
+import android.os.Message;
+import android.os.Process;
+import android.os.SELinux;
+import android.os.SystemProperties;
+import android.os.UserHandle;
+import android.provider.Settings;
+import android.text.FontConfig;
+import android.text.TextUtils;
+import android.util.Log;
+import android.util.Slog;
+import android.util.Xml;
+
+public class FontService extends IFontService.Stub {
+    private static final String TAG = "FontService";
+    private static final File SYSTEM_THEME_DIR = new File(Environment.getDataSystemDirectory(),
+            "theme");
+    private static final File SYSTEM_THEME_FONT_DIR = new File(SYSTEM_THEME_DIR, "fonts");
+    private static final File SYSTEM_THEME_CACHE_DIR = new File(SYSTEM_THEME_DIR, "cache");
+    private static final File SYSTEM_THEME_PREVIEW_CACHE_DIR = new File(SYSTEM_THEME_DIR,
+            "font_previews");
+    private static final String FONTS_XML = "fonts.xml";
+    private static final String FONT_IDENTIFIER = "custom_rom_font_provider";
+    private static final String SUBSTRATUM_INTENT = "projekt.substratum.THEME";
+
+    private Context mContext;
+    private FontHandler mFontHandler;
+    private HandlerThread mFontWorker;
+    private final Map<String, List<FontInfo>> mFontMap = new HashMap<>();
+    private final FontInfo mFontInfo = new FontInfo();
+
+    public static class Lifecycle extends SystemService {
+        FontService mService;
+
+        public Lifecycle(Context context) {
+            super(context);
+        }
+
+        @Override
+        public void onStart() {
+            mService = new FontService(getContext());
+            publishBinderService("dufont", mService);
+        }
+
+        @Override
+        public void onBootPhase(int phase) {
+            if (phase == PHASE_SYSTEM_SERVICES_READY) {
+                String cryptState = SystemProperties.get("vold.decrypt");
+                // wait until decrypted if we use FDE or just go one if not (cryptState will be empty then)
+                if (TextUtils.isEmpty(cryptState) || cryptState.equals("trigger_restart_framework")) {
+                    if (makeDir(SYSTEM_THEME_DIR)) {
+                        makeDir(SYSTEM_THEME_PREVIEW_CACHE_DIR);
+                        restoreconThemeDir();
+                    }
+                    mService.sendInitializeFontMapMessage();
+                }
+            }
+        }
+    }
+
+    private class FontHandler extends Handler {
+        private static final int MESSAGE_INITIALIZE_MAP = 1;
+        private static final int MESSAGE_CHANGE_FONT = 2;
+        private static final int MESSAGE_PACKAGE_ADDED_OR_UPDATED = 3;
+        private static final int MESSAGE_PACKAGE_REMOVED = 4;
+
+        public FontHandler(Looper looper) {
+            super(looper);
+        }
+
+        @Override
+        public void handleMessage(Message msg) {
+            String packageName;
+            switch (msg.what) {
+                case MESSAGE_INITIALIZE_MAP:
+                    initializeFontMap();
+                    break;
+                case MESSAGE_CHANGE_FONT:
+                    final FontInfo info = (FontInfo) msg.obj;
+                    applyFontsPriv(info);
+                    break;
+                case MESSAGE_PACKAGE_ADDED_OR_UPDATED:
+                    packageName = (String) msg.obj;
+                    boolean isFontProvider = isPackageFontProvider(packageName);
+                    if (isFontProvider) {
+                        Log.e(TAG, packageName + " was added or updated. Adding or updating fonts");
+                        synchronized (mFontMap) {
+                            processFontPackage(packageName);
+                        }
+                    }
+                    break;
+                case MESSAGE_PACKAGE_REMOVED:
+                    packageName = (String) msg.obj;
+                    boolean hadFonts = mFontMap.containsKey(packageName);
+                    if (hadFonts) {
+                        synchronized (mFontMap) {
+                            Log.e(TAG,
+                                    packageName + " was removed. Clearing fonts from provider map");
+                            removeFontPackage(packageName);
+                        }
+                        // if removed package provided current font, reset to system
+                        if (TextUtils.equals(packageName, mFontInfo.packageName)) {
+                            Log.e(TAG, packageName
+                                    + " provided the current font. Restoring to system font");
+                            applyFontsPriv(FontInfo.getDefaultFontInfo());
+                        }
+                    }
+                    break;
+                default:
+                    Log.w(TAG, "Unknown message " + msg.what);
+                    break;
+            }
+        }
+    }
+
+    private class PackageReceiver extends BroadcastReceiver {
+        @Override
+        public void onReceive(@NonNull
+        final Context context, @NonNull
+        final Intent intent) {
+            final Uri data = intent.getData();
+            if (data == null) {
+                Slog.e(TAG, "Cannot handle package broadcast with null data");
+                return;
+            }
+            final String packageName = data.getSchemeSpecificPart();
+
+            Message msg;
+            switch (intent.getAction()) {
+                case ACTION_PACKAGE_ADDED:
+                case ACTION_PACKAGE_CHANGED:
+                    msg = mFontHandler.obtainMessage(
+                            FontHandler.MESSAGE_PACKAGE_ADDED_OR_UPDATED);
+                    msg.obj = packageName;
+                    mFontHandler.sendMessage(msg);
+                    break;
+                case ACTION_PACKAGE_REMOVED:
+                    msg = mFontHandler.obtainMessage(
+                            FontHandler.MESSAGE_PACKAGE_REMOVED);
+                    msg.obj = packageName;
+                    mFontHandler.sendMessage(msg);
+                    break;
+                default:
+                    break;
+            }
+        }
+    }
+
+    public FontService(Context context) {
+        mContext = context;
+        mFontWorker = new HandlerThread("FontServiceWorker", Process.THREAD_PRIORITY_BACKGROUND);
+        mFontWorker.start();
+        mFontHandler = new FontHandler(mFontWorker.getLooper());
+        mFontInfo.updateFrom(getCurrentFontInfoFromProvider());
+        IntentFilter packageFilter = new IntentFilter();
+        packageFilter.addAction(ACTION_PACKAGE_ADDED);
+        packageFilter.addAction(ACTION_PACKAGE_CHANGED);
+        packageFilter.addAction(ACTION_PACKAGE_REMOVED);
+        packageFilter.addDataScheme("package");
+        mContext.registerReceiverAsUser(new PackageReceiver(), UserHandle.ALL,
+                packageFilter, null, null);
+    }
+
+    @Override
+    public void applyFont(FontInfo info) {
+        enforceFontService();
+        if (info.packageName == null
+                || info.fontName == null
+                || info.previewPath == null) {
+            info.updateFrom(FontInfo.getDefaultFontInfo());
+        }
+        Log.e(TAG, "applyFonts() packageName = " + info.toString());
+        Message msg = mFontHandler.obtainMessage(
+                FontHandler.MESSAGE_CHANGE_FONT);
+        msg.obj = info;
+        mFontHandler.sendMessage(msg);
+    }
+
+    @Override
+    public FontInfo getFontInfo() {
+        enforceFontService();
+        FontInfo info = new FontInfo(mFontInfo);
+        return info;
+    }
+
+    @Override
+    public Map<String, List<FontInfo>> getAllFonts() {
+        enforceFontService();
+        return mFontMap;
+    }
+
+    private void sendInitializeFontMapMessage() {
+        Message msg = mFontHandler.obtainMessage(
+                FontHandler.MESSAGE_INITIALIZE_MAP);
+        mFontHandler.sendMessage(msg);
+    }
+
+    private void initializeFontMap() {
+        List<String> packageList = getInstalledFontPackagesFromProvider();
+        for (String pkg : packageList) {
+            processFontPackage(pkg);
+        }
+        Log.e(TAG, " Font map initialized- " + mFontMap.toString());
+    }
+
+    private void processFontPackage(String packageName) {
+        List<FontInfo> infoList = new ArrayList<FontInfo>();
+        Context appContext = getAppContext(packageName);
+        AssetManager am = appContext.getAssets();
+        List<String> fontZips = getFontsFromPackage(packageName);
+        File packageFontPreviewDir = new File(SYSTEM_THEME_PREVIEW_CACHE_DIR, packageName);
+        if (packageFontPreviewDir.exists() && packageFontPreviewDir.isDirectory()) {
+            FileUtils.deleteContentsAndDir(packageFontPreviewDir);
+        }
+        makeDir(packageFontPreviewDir);
+        // iterate list of fonts package provides
+        for (String fontZip : fontZips) {
+            // create preview directory for this font
+            // for now, just delete and do it again
+            // TODO: clean this up
+            String sanitizedZipName = sanitizeZipName(fontZip);
+            File currentFontPreviewDir = new File(packageFontPreviewDir, sanitizedZipName);
+            makeDir(currentFontPreviewDir);
+
+            Log.e(TAG, "CurrentFontPreviewDir absolute path = "
+                    + currentFontPreviewDir.getAbsolutePath());
+
+            // copy zip to preview cache
+            File fontZipFile = new File(currentFontPreviewDir, fontZip);
+            try (InputStream inputStream = am.open("fonts/" + fontZip)) {
+                FileUtils.copyToFileOrThrow(inputStream, fontZipFile);
+            } catch (IOException e) {
+                Log.e(TAG, "There is an exception when trying to copy themed fonts", e);
+            }
+
+            // get fonts.xml from zip
+            File fontXmlFile = new File(currentFontPreviewDir, FONTS_XML);
+            unzipFile(fontZipFile, fontXmlFile, FONTS_XML);
+
+            // parse fonts.xml for name of preview typeface
+            String fontFileName = getPreviewFontNameFromXml(fontXmlFile,
+                    currentFontPreviewDir.getAbsolutePath());
+
+            // extract tff file from zip
+            File fontFile = new File(fontFileName);
+            unzipFile(fontZipFile, fontFile, fontFile.getName());
+
+            // clean up workspace
+            if (fontXmlFile.exists()) {
+                fontXmlFile.delete();
+            }
+            if (fontZipFile.exists()) {
+                fontZipFile.delete();
+            }
+
+            // create FontInfo and add to list
+            FontInfo fontInfo = new FontInfo();
+            fontInfo.fontName = sanitizedZipName;
+            fontInfo.packageName = packageName;
+            fontInfo.previewPath = fontFile.getAbsolutePath();
+            infoList.add(fontInfo);
+        }
+        // add or replace font list
+        if (mFontMap.containsKey(packageName)) {
+            mFontMap.replace(packageName, infoList);
+        } else {
+            mFontMap.put(packageName, infoList);
+        }
+
+        // update package list in provider
+        List<String> packageList = getInstalledFontPackagesFromProvider();
+        if (!packageList.contains(packageName)) {
+            packageList.add(packageName);
+            putFontPackagesIntoProvider(packageList);
+        }
+        Log.e(TAG, "The new FontInfo map: " + mFontMap.toString());
+    }
+
+    private void removeFontPackage(String packageName) {
+        if (!mFontMap.containsKey(packageName)) {
+            return;
+        }
+        File packageFontPreviewDir = new File(SYSTEM_THEME_PREVIEW_CACHE_DIR, packageName);
+        if (packageFontPreviewDir.exists() && packageFontPreviewDir.isDirectory()) {
+            FileUtils.deleteContentsAndDir(packageFontPreviewDir);
+        }
+        mFontMap.remove(packageName, mFontMap.get(packageName));
+
+        // update package list in provider
+        List<String> packageList = getInstalledFontPackagesFromProvider();
+        if (packageList.contains(packageName)) {
+            packageList.remove(packageName);
+            putFontPackagesIntoProvider(packageList);
+        }
+    }
+
+    private static String getPreviewFontNameFromXml(File xmlFile, String path) {
+        FontConfig fontConfig = null;
+        try {
+            fontConfig = FontListParser.parse(xmlFile, path);
+        } catch (Exception e) {
+            Log.e(TAG, "Exception thrown parsing fonts.xml! " + e.toString());
+            return null;
+        }
+        if (fontConfig != null) {
+            List<FontConfig.Family> families = fontConfig.getFamilies();
+            if (families != null) {
+                FontConfig.Family family = families.get(0);
+                if (family != null) {
+                    FontConfig.Font[] fonts = family.getFonts();
+                    if (fonts != null && fonts.length > 0) {
+                        FontConfig.Font font = fonts[0];
+                        if (font != null) {
+                            Log.e(TAG, "Font found from parsing fonts.xml! " + font.getFontName());
+                            return font.getFontName();
+                        }
+                    }
+                }
+            }
+        }
+        return null;
+    }
+
+    private boolean isPackageFontProvider(String packageName) {
+        // check if the package res bool is set first
+        Context appContext = getAppContext(packageName);
+        int id = appContext.getResources().getIdentifier(FONT_IDENTIFIER,
+                "bool",
+                appContext.getPackageName());
+        if (id != 0) {
+            return true;
+        }
+
+        // now check for Substratum package
+        // TODO: why resolve for ALL packages? Just analyze this package
+        List<ResolveInfo> subsPackages = new ArrayList<ResolveInfo>();
+        PackageManager pm = mContext.getPackageManager();
+        Intent i = new Intent(SUBSTRATUM_INTENT);
+        i.addCategory(Intent.CATEGORY_DEFAULT);
+        subsPackages.addAll(pm.queryIntentActivities(i,
+                PackageManager.GET_META_DATA));
+        for (ResolveInfo info : subsPackages) {
+            if (TextUtils.equals(info.activityInfo.packageName, packageName)) {
+                return true;
+            }
+        }
+        // bail out
+        return false;
+    }
+
+    private List<String> getFontsFromPackage(String packageName) {
+        Context appContext = getAppContext(packageName);
+        AssetManager am = appContext.getAssets();
+        List<String> list = new ArrayList<String>();
+        try {
+            list.addAll(Arrays.asList(am.list("fonts")));
+        } catch (Exception e) {
+            Log.e(TAG, appContext.getPackageName() + "did not have a fonts folder!");
+        }
+
+        // remove Substratum preview files, only grap zips
+        List<String> previews = new ArrayList<String>();
+        for (String font : list) {
+            if (font.contains("preview") || !font.endsWith(".zip")) {
+                previews.add(font);
+            }
+        }
+        list.removeAll(previews);
+
+        Log.e(TAG, packageName + " has the following fonts - " + list.toString());
+        return list;
+    }
+
+    private void putFontPackagesIntoProvider(List<String> packages) {
+        StringBuilder builder = new StringBuilder();
+        for (int i = 0; i < packages.size(); i++) {
+            builder.append(packages.get(i));
+            builder.append("|");
+        }
+        Settings.System.putStringForUser(mContext.getContentResolver(),
+                Settings.System.FONT_PACKAGES,
+                builder.toString(), UserHandle.USER_CURRENT);
+    }
+
+    private List<String> getInstalledFontPackagesFromProvider() {
+        String packages = Settings.System.getStringForUser(mContext.getContentResolver(),
+                Settings.System.FONT_PACKAGES, UserHandle.USER_CURRENT);
+        List<String> packageList = new ArrayList<>();
+        if (TextUtils.isEmpty(packages)) {
+            packageList.addAll(Arrays.asList(mContext.getResources()
+                    .getStringArray(com.android.internal.R.array.config_fontPackages)));
+        } else {
+            packageList.addAll(Arrays.asList(packages.split("\\|")));
+        }
+        return packageList;
+    }
+
+    private void putCurrentFontInfoInProvider(FontInfo fontInfo) {
+        Settings.System.putStringForUser(mContext.getContentResolver(), Settings.System.FONT_INFO,
+                fontInfo.toDelimitedString(), UserHandle.USER_CURRENT);
+    }
+
+    // index 0 is package name, index 1 is font name, index 2 is previewPath
+    private FontInfo getCurrentFontInfoFromProvider() {
+        String info = Settings.System.getStringForUser(mContext.getContentResolver(),
+                Settings.System.FONT_INFO, UserHandle.USER_CURRENT);
+        FontInfo fontInfo = new FontInfo();
+        if (TextUtils.isEmpty(info)) {
+            fontInfo.updateFrom(FontInfo.getDefaultFontInfo());
+        } else {
+            List<String> infoList = Arrays.asList(info.split("\\|"));
+            fontInfo.packageName = infoList.get(0);
+            fontInfo.fontName = infoList.get(1);
+            fontInfo.previewPath = infoList.get(2);
+        }
+        return fontInfo;
+    }
+
+    private Context getAppContext(String packageName) {
+        Context ctx = null;
+        try {
+            ctx = mContext.createPackageContext(packageName,
+                    Context.CONTEXT_IGNORE_SECURITY);
+        } catch (NameNotFoundException e) {
+            Log.e(TAG, "Failed to get " + packageName + " context");
+        }
+        return ctx;
+    }
+
+    private void applyFontsPriv(FontInfo info) {
+        Log.e(TAG, "applyFontsPriv() packageName = " + info.toString());
+        final long ident = Binder.clearCallingIdentity();
+        try {
+            if (info.equals(FontInfo.getDefaultFontInfo())) {
+                clearFonts();
+            } else {
+                copyFonts(info);
+            }
+            Intent intent = new Intent("com.android.server.ACTION_FONT_CHANGED");
+            intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY
+                        | Intent.FLAG_RECEIVER_FOREGROUND);
+            mContext.sendBroadcastAsUser(intent, UserHandle.CURRENT);
+        } finally {
+            Binder.restoreCallingIdentity(ident);
+        }
+    }
+
+    private void copyFonts(FontInfo info) {
+        // Prepare local cache dir for font package assembly
+
+        File cacheDir = new File(SYSTEM_THEME_CACHE_DIR, "FontCache");
+        if (cacheDir.exists()) {
+            FileUtils.deleteContentsAndDir(cacheDir);
+        }
+
+        boolean created = cacheDir.mkdirs();
+        if (!created) {
+            Log.e(TAG, "Could not create cache directory...");
+        }
+
+        // Append zip to filename since it is probably removed
+        // for list presentation
+        String zipFileName = info.fontName;
+        if (!zipFileName.endsWith(".zip")) {
+            zipFileName = zipFileName + ".zip";
+        }
+
+        // Copy target themed fonts zip to our cache dir
+        Context themeContext = getAppContext(info.packageName);
+        AssetManager am = themeContext.getAssets();
+        File fontZip = new File(cacheDir, zipFileName);
+        try (InputStream inputStream = am.open("fonts/" + zipFileName)) {
+            FileUtils.copyToFileOrThrow(inputStream, fontZip);
+        } catch (IOException e) {
+            Log.e(TAG, "There is an exception when trying to copy themed fonts", e);
+        }
+
+        // Unzip new fonts and delete zip file, overwriting any system fonts
+        unzip(fontZip.getAbsolutePath(), cacheDir.getAbsolutePath());
+
+        boolean deleted = fontZip.delete();
+        if (!deleted) {
+            Log.e(TAG, "Could not delete ZIP file");
+        }
+
+        // Prepare system theme fonts folder and copy new fonts folder from our cache
+        FileUtils.deleteContentsAndDir(SYSTEM_THEME_FONT_DIR);
+        makeDir(SYSTEM_THEME_FONT_DIR);
+        copyDir(cacheDir.getAbsolutePath(), SYSTEM_THEME_FONT_DIR.getAbsolutePath());
+
+        // Let system know it's time for a font change
+        FileUtils.deleteContentsAndDir(cacheDir);
+        refreshFonts();
+        mFontInfo.updateFrom(info);
+        putCurrentFontInfoInProvider(mFontInfo);
+    }
+
+    private static String sanitizeZipName(String zipFile) {
+        return zipFile.substring(0, zipFile.length() - 4);
+    }
+
+    private void refreshFonts() {
+        // Set permissions on font files and config xml
+        if (SYSTEM_THEME_FONT_DIR.exists()) {
+            // Set permissions
+            setPermissionsRecursive(SYSTEM_THEME_FONT_DIR,
+                    FileUtils.S_IRWXU | FileUtils.S_IRGRP | FileUtils.S_IRWXO,
+                    FileUtils.S_IRWXU | FileUtils.S_IRWXG | FileUtils.S_IROTH | FileUtils.S_IXOTH);
+            restoreconThemeDir();
+        }
+        // Notify zygote that themes need a refresh
+        SystemProperties.set("sys.refresh_theme", "1");
+        float fontSize = Settings.System.getFloatForUser(mContext.getContentResolver(),
+                Settings.System.FONT_SCALE, 1.0f, UserHandle.USER_CURRENT);
+        Settings.System.putFloatForUser(mContext.getContentResolver(),
+                Settings.System.FONT_SCALE, (fontSize + 0.0000001f), UserHandle.USER_CURRENT);
+    }
+
+    private void clearFonts() {
+        FileUtils.deleteContentsAndDir(SYSTEM_THEME_FONT_DIR);
+        refreshFonts();
+        mFontInfo.updateFrom(FontInfo.getDefaultFontInfo());
+        putCurrentFontInfoInProvider(mFontInfo);
+    }
+
+    private void enforceFontService() {
+        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.ACCESS_FONT_MANAGER,
+                "FontService");
+    }
+
+    private static void setPermissions(File path, int permissions) {
+        FileUtils.setPermissions(path, permissions, -1, -1);
+    }
+
+    private static void setPermissionsRecursive(File dir, int file, int folder) {
+        if (!dir.isDirectory()) {
+            setPermissions(dir, file);
+            return;
+        }
+
+        for (File child : dir.listFiles()) {
+            if (child.isDirectory()) {
+                setPermissionsRecursive(child, file, folder);
+                setPermissions(child, folder);
+            } else {
+                setPermissions(child, file);
+            }
+        }
+
+        setPermissions(dir, folder);
+    }
+
+    private static boolean restoreconThemeDir() {
+        return SELinux.restoreconRecursive(SYSTEM_THEME_DIR);
+    }
+
+    private static boolean makeDir(File dir) {
+        if (dir.exists()) {
+            return dir.isDirectory();
+        }
+        if (dir.mkdirs()) {
+            int permissions = FileUtils.S_IRWXU | FileUtils.S_IRWXG |
+                    FileUtils.S_IRWXO;
+            SELinux.restorecon(dir);
+            return FileUtils.setPermissions(dir, permissions, -1, -1) == 0;
+        }
+        return false;
+    }
+
+    private static boolean copyDir(String src, String dst) {
+        File[] files = new File(src).listFiles();
+        boolean success = true;
+
+        if (files != null) {
+            for (File file : files) {
+                File newFile = new File(dst + File.separator +
+                        file.getName());
+                if (file.isDirectory()) {
+                    success &= copyDir(file.getAbsolutePath(),
+                            newFile.getAbsolutePath());
+                } else {
+                    success &= FileUtils.copyFile(file, newFile);
+                }
+            }
+        } else {
+            // not a directory
+            success = false;
+        }
+        return success;
+    }
+
+    private static void unzipFile(File zipFile, File destFile, String fileName) {
+        try {
+            ZipInputStream zis = new ZipInputStream(
+                    new BufferedInputStream(new FileInputStream(zipFile)));
+            ZipEntry ze;
+            int count;
+            byte[] buffer = new byte[8192];
+            boolean isDone = false;
+            while (!isDone && (ze = zis.getNextEntry()) != null) {
+                if (ze.isDirectory() || !ze.getName().equals(fileName)) {
+                    continue;
+                }
+                if (ze.getName().equals(fileName)) {
+                    Log.e(TAG, "iterating " + zipFile.getName() + "Found " + fileName
+                            + ", trying to extract");
+                    FileOutputStream fout = new FileOutputStream(destFile);
+                    try {
+                        while ((count = zis.read(buffer)) != -1)
+                            fout.write(buffer, 0, count);
+                    } finally {
+                        fout.close();
+                    }
+                    isDone = true;
+                }
+            }
+            zis.close();
+        } catch (IOException e) {
+            Log.e(TAG, "There is an exception when trying to unzip", e);
+        }
+    }
+
+    private static void unzip(String source, String destination) {
+        try (ZipInputStream inputStream = new ZipInputStream(
+                new BufferedInputStream(new FileInputStream(source)))) {
+            ZipEntry zipEntry;
+            int count;
+            byte[] buffer = new byte[8192];
+
+            while ((zipEntry = inputStream.getNextEntry()) != null) {
+                File file = new File(destination, zipEntry.getName());
+                File dir = zipEntry.isDirectory() ? file : file.getParentFile();
+
+                if (!dir.isDirectory() && !dir.mkdirs()) {
+                    throw new FileNotFoundException("Failed to ensure directory: " +
+                            dir.getAbsolutePath());
+                }
+
+                if (zipEntry.isDirectory()) {
+                    continue;
+                }
+
+                try (FileOutputStream outputStream = new FileOutputStream(file)) {
+                    while ((count = inputStream.read(buffer)) != -1) {
+                        outputStream.write(buffer, 0, count);
+                    }
+                }
+            }
+        } catch (IOException e) {
+            Log.e(TAG, "There is an exception when trying to unzip", e);
+        }
+    }
+}
diff --git a/services/core/java/com/android/server/am/ActivityManagerService.java b/services/core/java/com/android/server/am/ActivityManagerService.java
index cef30f92ad1..c1495cedcac 100644
--- a/services/core/java/com/android/server/am/ActivityManagerService.java
+++ b/services/core/java/com/android/server/am/ActivityManagerService.java
@@ -625,6 +625,8 @@ public class ActivityManagerService extends IActivityManager.Stub
     // as one line, but close enough for now.
     static final int RESERVED_BYTES_PER_LOGCAT_LINE = 100;
 
+    static final String PROP_REFRESH_THEME = "sys.refresh_theme";
+
     /** If a UID observer takes more than this long, send a WTF. */
     private static final int SLOW_UID_OBSERVER_THRESHOLD_MS = 20;
 
@@ -4344,6 +4346,13 @@ public class ActivityManagerService extends IActivityManager.Stub
                 runtimeFlags |= policyBits;
             }
 
+            // Check if zygote should refresh its fonts
+            boolean refreshTheme = false;
+            if (SystemProperties.getBoolean(PROP_REFRESH_THEME, false)) {
+                SystemProperties.set(PROP_REFRESH_THEME, "false");
+                refreshTheme = true;
+            }
+
             String invokeWith = null;
             if ((app.info.flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0) {
                 // Debuggable apps may include a wrapper script with their library directory.
@@ -4385,7 +4394,7 @@ public class ActivityManagerService extends IActivityManager.Stub
             final String entryPoint = "android.app.ActivityThread";
 
             return startProcessLocked(hostingType, hostingNameStr, entryPoint, app, uid, gids,
-                    runtimeFlags, mountExternal, seInfo, requiredAbi, instructionSet, invokeWith,
+                    runtimeFlags, mountExternal, seInfo, requiredAbi, instructionSet, invokeWith, refreshTheme,
                     startTime);
         } catch (RuntimeException e) {
             Slog.e(TAG, "Failure starting process " + app.processName, e);
@@ -4405,7 +4414,7 @@ public class ActivityManagerService extends IActivityManager.Stub
     @GuardedBy("this")
     private boolean startProcessLocked(String hostingType, String hostingNameStr, String entryPoint,
             ProcessRecord app, int uid, int[] gids, int runtimeFlags, int mountExternal,
-            String seInfo, String requiredAbi, String instructionSet, String invokeWith,
+            String seInfo, String requiredAbi, String instructionSet, String invokeWith, boolean refreshTheme,
             long startTime) {
         app.pendingStart = true;
         app.killedByAm = false;
@@ -4432,7 +4441,7 @@ public class ActivityManagerService extends IActivityManager.Stub
                     }
                     final ProcessStartResult startResult = startProcess(app.hostingType, entryPoint,
                             app, app.startUid, gids, runtimeFlags, mountExternal, app.seInfo,
-                            requiredAbi, instructionSet, invokeWith, app.startTime);
+                            requiredAbi, instructionSet, invokeWith, refreshTheme, app.startTime);
                     synchronized (ActivityManagerService.this) {
                         handleProcessStartedLocked(app, startResult, startSeq);
                     }
@@ -4452,7 +4461,7 @@ public class ActivityManagerService extends IActivityManager.Stub
             try {
                 final ProcessStartResult startResult = startProcess(hostingType, entryPoint, app,
                         uid, gids, runtimeFlags, mountExternal, seInfo, requiredAbi, instructionSet,
-                        invokeWith, startTime);
+                        invokeWith, refreshTheme, startTime);
                 handleProcessStartedLocked(app, startResult.pid, startResult.usingWrapper,
                         startSeq, false);
             } catch (RuntimeException e) {
@@ -4469,7 +4478,7 @@ public class ActivityManagerService extends IActivityManager.Stub
     private ProcessStartResult startProcess(String hostingType, String entryPoint,
             ProcessRecord app, int uid, int[] gids, int runtimeFlags, int mountExternal,
             String seInfo, String requiredAbi, String instructionSet, String invokeWith,
-            long startTime) {
+            boolean refreshTheme, long startTime) {
         try {
             Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "Start proc: " +
                     app.processName);
@@ -4479,13 +4488,13 @@ public class ActivityManagerService extends IActivityManager.Stub
                 startResult = startWebView(entryPoint,
                         app.processName, uid, uid, gids, runtimeFlags, mountExternal,
                         app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,
-                        app.info.dataDir, null,
+                        app.info.dataDir, null, true,
                         new String[] {PROC_START_SEQ_IDENT + app.startSeq});
             } else {
                 startResult = Process.start(entryPoint,
                         app.processName, uid, uid, gids, runtimeFlags, mountExternal,
                         app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,
-                        app.info.dataDir, invokeWith,
+                        app.info.dataDir, invokeWith, true,
                         new String[] {PROC_START_SEQ_IDENT + app.startSeq});
             }
             checkTime(startTime, "startProcess: returned from zygote!");
diff --git a/services/java/com/android/server/SystemServer.java b/services/java/com/android/server/SystemServer.java
index b1683c4d2f2..85628d1757d 100644
--- a/services/java/com/android/server/SystemServer.java
+++ b/services/java/com/android/server/SystemServer.java
@@ -232,6 +232,8 @@ public final class SystemServer {
             "com.android.server.slice.SliceManagerService$Lifecycle";
     private static final String CAR_SERVICE_HELPER_SERVICE_CLASS =
             "com.android.internal.car.CarServiceHelperService";
+    private static final String FONT_SERVICE_CLASS =
+            "com.android.server.FontService$Lifecycle";
 
     private static final String PERSISTENT_DATA_BLOCK_PROP = "ro.frp.pst";
 
@@ -837,6 +839,11 @@ public final class SystemServer {
             SQLiteCompatibilityWalFlags.reset();
             traceEnd();
 
+            // Manages fonts
+            traceBeginAndSlog("StartFontService");
+            mSystemServiceManager.startService(FONT_SERVICE_CLASS);
+            traceEnd();
+
             // Records errors and logs, for example wtf()
             // Currently this service indirectly depends on SettingsProvider so do this after
             // InstallSystemProviders.
-- 
2.20.1

